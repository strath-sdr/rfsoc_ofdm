-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\OFDM_Rx_HW\ofdm_rx_src_Reciprocal_core.vhd
-- Created: 2022-03-24 22:06:16
-- 
-- Generated by MATLAB 9.8 and HDL Coder 3.16
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: ofdm_rx_src_Reciprocal_core
-- Source Path: Reciprocal/Reciprocal_core
-- Hierarchy Level: 5
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.ofdm_rx_src_OFDMRx_pkg.ALL;

ENTITY ofdm_rx_src_Reciprocal_core IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        xin                               :   IN    std_logic_vector(22 DOWNTO 0);  -- sfix23_En19
        ain                               :   IN    std_logic_vector(15 DOWNTO 0);  -- ufix16_En16
        xout                              :   OUT   std_logic_vector(22 DOWNTO 0);  -- sfix23_En19
        aout                              :   OUT   std_logic_vector(15 DOWNTO 0)  -- ufix16_En16
        );
END ofdm_rx_src_Reciprocal_core;


ARCHITECTURE rtl OF ofdm_rx_src_Reciprocal_core IS

  -- Signals
  SIGNAL const3                           : signed(22 DOWNTO 0);  -- sfix23_En19
  SIGNAL ain_unsigned                     : unsigned(15 DOWNTO 0);  -- ufix16_En16
  SIGNAL amul                             : signed(22 DOWNTO 0);  -- sfix23_En19
  SIGNAL xin_signed                       : signed(22 DOWNTO 0);  -- sfix23_En19
  SIGNAL mul1_mul_temp                    : signed(45 DOWNTO 0);  -- sfix46_En38
  SIGNAL mulout1                          : signed(22 DOWNTO 0);  -- sfix23_En19
  SIGNAL mulout1delay                     : signed(22 DOWNTO 0);  -- sfix23_En19
  SIGNAL xindelay1                        : signed(22 DOWNTO 0);  -- sfix23_En19
  SIGNAL mul2_mul_temp                    : signed(45 DOWNTO 0);  -- sfix46_En38
  SIGNAL mulout2                          : signed(22 DOWNTO 0);  -- sfix23_En19
  SIGNAL mulout2delay                     : signed(22 DOWNTO 0);  -- sfix23_En19
  SIGNAL subout                           : signed(22 DOWNTO 0);  -- sfix23_En19
  SIGNAL shiftout                         : signed(22 DOWNTO 0);  -- sfix23_En19
  SIGNAL shiftoutdelay                    : signed(22 DOWNTO 0);  -- sfix23_En19
  SIGNAL xindelay3_reg_reg                : vector_of_signed23(0 TO 1);  -- sfix23 [2]
  SIGNAL xindelay3                        : signed(22 DOWNTO 0);  -- sfix23_En19
  SIGNAL mul2_mul_temp_1                  : signed(45 DOWNTO 0);  -- sfix46_En38
  SIGNAL mulout3                          : signed(22 DOWNTO 0);  -- sfix23_En19
  SIGNAL xout_tmp                         : signed(22 DOWNTO 0);  -- sfix23_En19
  SIGNAL aout_reg_reg                     : vector_of_unsigned16(0 TO 3);  -- ufix16 [4]
  SIGNAL aout_tmp                         : unsigned(15 DOWNTO 0);  -- ufix16_En16

BEGIN
  -- Iteration Core of the RecipSqrt Implementation using Newton Method

  const3 <= to_signed(16#180000#, 23);

  ain_unsigned <= unsigned(ain);

  amul <= signed(resize(ain_unsigned & '0' & '0' & '0', 23));

  xin_signed <= signed(xin);

  mul1_mul_temp <= amul * xin_signed;
  mulout1 <= mul1_mul_temp(41 DOWNTO 19) + ('0' & mul1_mul_temp(18));

  xinterm1_reg_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      mulout1delay <= to_signed(16#000000#, 23);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        mulout1delay <= mulout1;
      END IF;
    END IF;
  END PROCESS xinterm1_reg_process;


  xindelay1_reg_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      xindelay1 <= to_signed(16#000000#, 23);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        xindelay1 <= xin_signed;
      END IF;
    END IF;
  END PROCESS xindelay1_reg_process;


  mul2_mul_temp <= mulout1delay * xindelay1;
  mulout2 <= mul2_mul_temp(41 DOWNTO 19) + ('0' & mul2_mul_temp(18));

  xinterm2_reg_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      mulout2delay <= to_signed(16#000000#, 23);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        mulout2delay <= mulout2;
      END IF;
    END IF;
  END PROCESS xinterm2_reg_process;


  subout <= const3 - mulout2delay;

  shiftout <= SHIFT_RIGHT(subout, 1);

  xinterm3_reg_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      shiftoutdelay <= to_signed(16#000000#, 23);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        shiftoutdelay <= shiftout;
      END IF;
    END IF;
  END PROCESS xinterm3_reg_process;


  xindelay3_reg_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      xindelay3_reg_reg <= (OTHERS => to_signed(16#000000#, 23));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        xindelay3_reg_reg(0) <= xindelay1;
        xindelay3_reg_reg(1) <= xindelay3_reg_reg(0);
      END IF;
    END IF;
  END PROCESS xindelay3_reg_process;

  xindelay3 <= xindelay3_reg_reg(1);

  mul2_mul_temp_1 <= shiftoutdelay * xindelay3;
  mulout3 <= mul2_mul_temp_1(41 DOWNTO 19) + ('0' & mul2_mul_temp_1(18));

  xout_reg_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      xout_tmp <= to_signed(16#000000#, 23);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        xout_tmp <= mulout3;
      END IF;
    END IF;
  END PROCESS xout_reg_process;


  xout <= std_logic_vector(xout_tmp);

  aout_reg_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      aout_reg_reg <= (OTHERS => to_unsigned(16#0000#, 16));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        aout_reg_reg(0) <= ain_unsigned;
        aout_reg_reg(1 TO 3) <= aout_reg_reg(0 TO 2);
      END IF;
    END IF;
  END PROCESS aout_reg_process;

  aout_tmp <= aout_reg_reg(3);

  aout <= std_logic_vector(aout_tmp);

END rtl;

