-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\OFDM_Rx_HW\ofdm_rx_src_OFDMRx.vhd
-- Created: 2022-03-24 22:06:16
-- 
-- Generated by MATLAB 9.8 and HDL Coder 3.16
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Model base rate: 4.16667e-09
-- Target subsystem base rate: 4.16667e-09
-- 
-- 
-- Clock Enable  Sample Time
-- -------------------------------------------------------------
-- ce_out        4.16667e-09
-- -------------------------------------------------------------
-- 
-- 
-- Output Signal                 Clock Enable  Sample Time
-- -------------------------------------------------------------
-- m_axis_tdata                  ce_out        4.16667e-09
-- m_axis_tvalid                 ce_out        4.16667e-09
-- -------------------------------------------------------------
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: ofdm_rx_src_OFDMRx
-- Source Path: OFDM_Rx_HW/OFDMRx
-- Hierarchy Level: 0
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY ofdm_rx_src_OFDMRx IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        clk_enable                        :   IN    std_logic;
        data                              :   IN    std_logic_vector(31 DOWNTO 0);  -- uint32
        valid                             :   IN    std_logic;
        threshold                         :   IN    std_logic_vector(31 DOWNTO 0);  -- uint32
        enable_threshold                  :   IN    std_logic_vector(31 DOWNTO 0);  -- uint32
        ce_out                            :   OUT   std_logic;
        m_axis_tdata                      :   OUT   std_logic_vector(31 DOWNTO 0);  -- uint32
        m_axis_tvalid                     :   OUT   std_logic
        );
END ofdm_rx_src_OFDMRx;


ARCHITECTURE rtl OF ofdm_rx_src_OFDMRx IS

  -- Component Declarations
  COMPONENT ofdm_rx_src_OFDMRx_tc
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          clk_enable                      :   IN    std_logic;
          enb                             :   OUT   std_logic;
          enb_1_1_1                       :   OUT   std_logic;
          enb_1_12_0                      :   OUT   std_logic;
          enb_1_12_1                      :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT ofdm_rx_src_Synchronisation
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          enb_1_12_1                      :   IN    std_logic;
          enb_1_12_0                      :   IN    std_logic;
          dataIn_re                       :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
          dataIn_im                       :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
          threshold                       :   IN    std_logic_vector(31 DOWNTO 0);  -- uint32
          DataOut_re                      :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
          DataOut_im                      :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
          FFTValidOut                     :   OUT   std_logic;
          dataValid                       :   OUT   std_logic;
          preambleValid                   :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT ofdm_rx_src_FFT
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb_1_12_0                      :   IN    std_logic;
          dataIn_re                       :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
          dataIn_im                       :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
          FFTValidIn                      :   IN    std_logic;
          dataValid                       :   IN    std_logic;
          preambleValid                   :   IN    std_logic;
          dataOut_re                      :   OUT   std_logic_vector(21 DOWNTO 0);  -- sfix22_En14
          dataOut_im                      :   OUT   std_logic_vector(21 DOWNTO 0);  -- sfix22_En14
          dataValidOut                    :   OUT   std_logic;
          preambleValidOut                :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT ofdm_rx_src_ChannelEstEq
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          enb_1_12_1                      :   IN    std_logic;
          enb_1_12_0                      :   IN    std_logic;
          dataIn_re                       :   IN    std_logic_vector(21 DOWNTO 0);  -- sfix22_En14
          dataIn_im                       :   IN    std_logic_vector(21 DOWNTO 0);  -- sfix22_En14
          dataValid                       :   IN    std_logic;
          preambleValid                   :   IN    std_logic;
          dataOut_re                      :   OUT   std_logic_vector(17 DOWNTO 0);  -- sfix18_En15
          dataOut_im                      :   OUT   std_logic_vector(17 DOWNTO 0);  -- sfix18_En15
          dataValidOut                    :   OUT   std_logic;
          chEstData                       :   OUT   std_logic_vector(31 DOWNTO 0)  -- uint32
          );
  END COMPONENT;

  COMPONENT ofdm_rx_src_PhaseTracking_1
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          enb_1_12_1                      :   IN    std_logic;
          enb_1_12_0                      :   IN    std_logic;
          dataIn_re                       :   IN    std_logic_vector(17 DOWNTO 0);  -- sfix18_En15
          dataIn_im                       :   IN    std_logic_vector(17 DOWNTO 0);  -- sfix18_En15
          dataValidIn                     :   IN    std_logic;
          dataOut_re                      :   OUT   std_logic_vector(17 DOWNTO 0);  -- sfix18_En15
          dataOut_im                      :   OUT   std_logic_vector(17 DOWNTO 0);  -- sfix18_En15
          dataValidOut                    :   OUT   std_logic
          );
  END COMPONENT;

  COMPONENT ofdm_rx_src_PhaseTracking_2
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          enb_1_12_1                      :   IN    std_logic;
          enb_1_12_0                      :   IN    std_logic;
          dataIn_re                       :   IN    std_logic_vector(17 DOWNTO 0);  -- sfix18_En15
          dataIn_im                       :   IN    std_logic_vector(17 DOWNTO 0);  -- sfix18_En15
          dataValidIn                     :   IN    std_logic;
          dataOut_re                      :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
          dataOut_im                      :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
          validOut                        :   OUT   std_logic
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : ofdm_rx_src_OFDMRx_tc
    USE ENTITY work.ofdm_rx_src_OFDMRx_tc(rtl);

  FOR ALL : ofdm_rx_src_Synchronisation
    USE ENTITY work.ofdm_rx_src_Synchronisation(rtl);

  FOR ALL : ofdm_rx_src_FFT
    USE ENTITY work.ofdm_rx_src_FFT(rtl);

  FOR ALL : ofdm_rx_src_ChannelEstEq
    USE ENTITY work.ofdm_rx_src_ChannelEstEq(rtl);

  FOR ALL : ofdm_rx_src_PhaseTracking_1
    USE ENTITY work.ofdm_rx_src_PhaseTracking_1(rtl);

  FOR ALL : ofdm_rx_src_PhaseTracking_2
    USE ENTITY work.ofdm_rx_src_PhaseTracking_2(rtl);

  -- Signals
  SIGNAL enb                              : std_logic;
  SIGNAL enb_1_12_1                       : std_logic;
  SIGNAL enb_1_12_0                       : std_logic;
  SIGNAL enb_1_1_1                        : std_logic;
  SIGNAL data_unsigned                    : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Delay_delOut                     : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Delay_ectrl                      : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Delay_out1                       : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Delay_last_value                 : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Rate_Transition_out1             : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Rate_Transition_out1_1           : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Bit_Slice_out1                   : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL Bit_Slice1_out1                  : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL Data_Type_Conversion_out1_re     : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Data_Type_Conversion_out1_im     : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL enable_threshold_unsigned        : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Rate_Transition1_out1            : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Rate_Transition1_out1_1          : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Rate_Transition1_out1_2          : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Bit_Slice2_out1                  : std_logic;  -- ufix1
  SIGNAL threshold_unsigned               : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Rate_Transition2_out1            : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Constant_out1                    : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Rate_Transition2_out1_1          : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Rate_Transition2_out1_2          : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Multiport_Switch_out1            : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Synchronisation_out1_re          : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL Synchronisation_out1_im          : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL Synchronisation_out2             : std_logic;
  SIGNAL Synchronisation_out3             : std_logic;
  SIGNAL Synchronisation_out4             : std_logic;
  SIGNAL FFT_out1_re                      : std_logic_vector(21 DOWNTO 0);  -- ufix22
  SIGNAL FFT_out1_im                      : std_logic_vector(21 DOWNTO 0);  -- ufix22
  SIGNAL FFT_out2                         : std_logic;
  SIGNAL FFT_out3                         : std_logic;
  SIGNAL ChannelEstEq_out1_re             : std_logic_vector(17 DOWNTO 0);  -- ufix18
  SIGNAL ChannelEstEq_out1_im             : std_logic_vector(17 DOWNTO 0);  -- ufix18
  SIGNAL ChannelEstEq_out2                : std_logic;
  SIGNAL y                                : std_logic_vector(31 DOWNTO 0);  -- ufix32
  SIGNAL PhaseTracking_1_out1_re          : std_logic_vector(17 DOWNTO 0);  -- ufix18
  SIGNAL PhaseTracking_1_out1_im          : std_logic_vector(17 DOWNTO 0);  -- ufix18
  SIGNAL PhaseTracking_1_out2             : std_logic;
  SIGNAL PhaseTracking_2_out1_re          : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL PhaseTracking_2_out1_im          : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL PhaseTracking_2_out2             : std_logic;
  SIGNAL Repeat_out1_im                   : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Repeat_out1_re                   : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL Bit_Concat_out1                  : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Upsample_zero                    : std_logic;
  SIGNAL Upsample_muxout                  : std_logic;
  SIGNAL Upsample_bypass_reg              : std_logic;  -- ufix1
  SIGNAL Upsample_bypassout               : std_logic;
  SIGNAL Upsample_int_delay_reg           : std_logic_vector(0 TO 4);  -- ufix1 [5]
  SIGNAL Upsample_out1                    : std_logic;
  SIGNAL delayMatch_reg                   : std_logic_vector(0 TO 11);  -- ufix1 [12]
  SIGNAL Upsample_out1_1                  : std_logic;

BEGIN
  -- Phase Tracking
  -- 
  -- One Tap Equaliser 
  -- 
  -- FFT Demodulation
  -- 
  -- Timing and Frequency 
  -- synchronisation  
  -- 
  -- Q0, I0
  -- 
  -- I0
  -- 
  -- Q0

  u_OFDMRx_tc : ofdm_rx_src_OFDMRx_tc
    PORT MAP( clk => clk,
              reset => reset,
              clk_enable => clk_enable,
              enb => enb,
              enb_1_1_1 => enb_1_1_1,
              enb_1_12_0 => enb_1_12_0,
              enb_1_12_1 => enb_1_12_1
              );

  u_Synchronisation : ofdm_rx_src_Synchronisation
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              enb_1_12_1 => enb_1_12_1,
              enb_1_12_0 => enb_1_12_0,
              dataIn_re => std_logic_vector(Data_Type_Conversion_out1_re),  -- sfix16_En14
              dataIn_im => std_logic_vector(Data_Type_Conversion_out1_im),  -- sfix16_En14
              threshold => std_logic_vector(Multiport_Switch_out1),  -- uint32
              DataOut_re => Synchronisation_out1_re,  -- sfix16_En14
              DataOut_im => Synchronisation_out1_im,  -- sfix16_En14
              FFTValidOut => Synchronisation_out2,
              dataValid => Synchronisation_out3,
              preambleValid => Synchronisation_out4
              );

  u_FFT : ofdm_rx_src_FFT
    PORT MAP( clk => clk,
              reset => reset,
              enb_1_12_0 => enb_1_12_0,
              dataIn_re => Synchronisation_out1_re,  -- sfix16_En14
              dataIn_im => Synchronisation_out1_im,  -- sfix16_En14
              FFTValidIn => Synchronisation_out2,
              dataValid => Synchronisation_out3,
              preambleValid => Synchronisation_out4,
              dataOut_re => FFT_out1_re,  -- sfix22_En14
              dataOut_im => FFT_out1_im,  -- sfix22_En14
              dataValidOut => FFT_out2,
              preambleValidOut => FFT_out3
              );

  u_ChannelEstEq : ofdm_rx_src_ChannelEstEq
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              enb_1_12_1 => enb_1_12_1,
              enb_1_12_0 => enb_1_12_0,
              dataIn_re => FFT_out1_re,  -- sfix22_En14
              dataIn_im => FFT_out1_im,  -- sfix22_En14
              dataValid => FFT_out2,
              preambleValid => FFT_out3,
              dataOut_re => ChannelEstEq_out1_re,  -- sfix18_En15
              dataOut_im => ChannelEstEq_out1_im,  -- sfix18_En15
              dataValidOut => ChannelEstEq_out2,
              chEstData => y  -- uint32
              );

  u_PhaseTracking_1 : ofdm_rx_src_PhaseTracking_1
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              enb_1_12_1 => enb_1_12_1,
              enb_1_12_0 => enb_1_12_0,
              dataIn_re => ChannelEstEq_out1_re,  -- sfix18_En15
              dataIn_im => ChannelEstEq_out1_im,  -- sfix18_En15
              dataValidIn => ChannelEstEq_out2,
              dataOut_re => PhaseTracking_1_out1_re,  -- sfix18_En15
              dataOut_im => PhaseTracking_1_out1_im,  -- sfix18_En15
              dataValidOut => PhaseTracking_1_out2
              );

  u_PhaseTracking_2 : ofdm_rx_src_PhaseTracking_2
    PORT MAP( clk => clk,
              reset => reset,
              enb => enb,
              enb_1_12_1 => enb_1_12_1,
              enb_1_12_0 => enb_1_12_0,
              dataIn_re => PhaseTracking_1_out1_re,  -- sfix18_En15
              dataIn_im => PhaseTracking_1_out1_im,  -- sfix18_En15
              dataValidIn => PhaseTracking_1_out2,
              dataOut_re => PhaseTracking_2_out1_re,  -- sfix16_En14
              dataOut_im => PhaseTracking_2_out1_im,  -- sfix16_En14
              validOut => PhaseTracking_2_out2
              );

  data_unsigned <= unsigned(data);

  
  Delay_ectrl <= Delay_delOut WHEN valid = '0' ELSE
      data_unsigned;

  Delay_lowered_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay_delOut <= to_unsigned(0, 32);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay_delOut <= Delay_ectrl;
      END IF;
    END IF;
  END PROCESS Delay_lowered_process;


  Delay_bypass_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay_last_value <= to_unsigned(0, 32);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Delay_last_value <= Delay_out1;
      END IF;
    END IF;
  END PROCESS Delay_bypass_process;


  
  Delay_out1 <= Delay_last_value WHEN valid = '0' ELSE
      Delay_delOut;

  Rate_Transition_output_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Rate_Transition_out1 <= to_unsigned(0, 32);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_12_1 = '1' THEN
        Rate_Transition_out1 <= Delay_out1;
      END IF;
    END IF;
  END PROCESS Rate_Transition_output_process;


  PipelineRegister_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Rate_Transition_out1_1 <= to_unsigned(0, 32);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_12_0 = '1' THEN
        Rate_Transition_out1_1 <= Rate_Transition_out1;
      END IF;
    END IF;
  END PROCESS PipelineRegister_process;


  Bit_Slice_out1 <= Rate_Transition_out1_1(15 DOWNTO 0);

  Bit_Slice1_out1 <= Rate_Transition_out1_1(31 DOWNTO 16);

  Data_Type_Conversion_out1_re <= signed(Bit_Slice_out1);
  Data_Type_Conversion_out1_im <= signed(Bit_Slice1_out1);

  enable_threshold_unsigned <= unsigned(enable_threshold);

  Rate_Transition1_output_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Rate_Transition1_out1 <= to_unsigned(0, 32);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_12_1 = '1' THEN
        Rate_Transition1_out1 <= enable_threshold_unsigned;
      END IF;
    END IF;
  END PROCESS Rate_Transition1_output_process;


  PipelineRegister1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Rate_Transition1_out1_1 <= to_unsigned(0, 32);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_12_0 = '1' THEN
        Rate_Transition1_out1_1 <= Rate_Transition1_out1;
      END IF;
    END IF;
  END PROCESS PipelineRegister1_process;


  Rate_Transition1_out1_2 <= Rate_Transition1_out1_1;

  Bit_Slice2_out1 <= Rate_Transition1_out1_2(0);

  threshold_unsigned <= unsigned(threshold);

  Rate_Transition2_output_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Rate_Transition2_out1 <= to_unsigned(0, 32);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_12_1 = '1' THEN
        Rate_Transition2_out1 <= threshold_unsigned;
      END IF;
    END IF;
  END PROCESS Rate_Transition2_output_process;


  Constant_out1 <= to_unsigned(1073741824, 32);

  PipelineRegister2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Rate_Transition2_out1_1 <= to_unsigned(0, 32);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_12_0 = '1' THEN
        Rate_Transition2_out1_1 <= Rate_Transition2_out1;
      END IF;
    END IF;
  END PROCESS PipelineRegister2_process;


  Rate_Transition2_out1_2 <= Rate_Transition2_out1_1;

  
  Multiport_Switch_out1 <= Constant_out1 WHEN Bit_Slice2_out1 = '0' ELSE
      Rate_Transition2_out1_2;

  Repeat_out1_im <= signed(PhaseTracking_2_out1_im);

  Repeat_out1_re <= signed(PhaseTracking_2_out1_re);

  Bit_Concat_out1 <= unsigned(Repeat_out1_im) & unsigned(Repeat_out1_re);

  m_axis_tdata <= std_logic_vector(Bit_Concat_out1);

  -- Upsample: Upsample by 12, Sample offset 5 
  Upsample_zero <= '0';

  
  Upsample_muxout <= PhaseTracking_2_out2 WHEN enb_1_12_1 = '1' ELSE
      Upsample_zero;

  -- Upsample bypass register
  Upsample_bypass_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Upsample_bypass_reg <= '0';
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_1_1 = '1' THEN
        Upsample_bypass_reg <= Upsample_muxout;
      END IF;
    END IF;
  END PROCESS Upsample_bypass_process;

  
  Upsample_bypassout <= Upsample_muxout WHEN enb_1_1_1 = '1' ELSE
      Upsample_bypass_reg;

  -- Upsample sample offset register
  Upsample_int_delay_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Upsample_int_delay_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' AND enb = '1' THEN
        Upsample_int_delay_reg(0) <= Upsample_bypassout;
        Upsample_int_delay_reg(1 TO 4) <= Upsample_int_delay_reg(0 TO 3);
      END IF;
    END IF;
  END PROCESS Upsample_int_delay_process;

  Upsample_out1 <= Upsample_int_delay_reg(4);

  delayMatch_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        delayMatch_reg(0) <= Upsample_out1;
        delayMatch_reg(1 TO 11) <= delayMatch_reg(0 TO 10);
      END IF;
    END IF;
  END PROCESS delayMatch_process;

  Upsample_out1_1 <= delayMatch_reg(11);

  ce_out <= enb_1_1_1;

  m_axis_tvalid <= Upsample_out1_1;

END rtl;

