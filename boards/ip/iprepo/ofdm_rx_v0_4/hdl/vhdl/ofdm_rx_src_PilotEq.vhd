-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\OFDM_Rx_HW\ofdm_rx_src_PilotEq.vhd
-- Created: 2022-03-24 22:06:16
-- 
-- Generated by MATLAB 9.8 and HDL Coder 3.16
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: ofdm_rx_src_PilotEq
-- Source Path: OFDM_Rx_HW/OFDMRx/PhaseTracking_1/GradientEstimate /PilotEq
-- Hierarchy Level: 3
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.ofdm_rx_src_OFDMRx_pkg.ALL;

ENTITY ofdm_rx_src_PilotEq IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        enb_1_12_1                        :   IN    std_logic;
        enb_1_12_0                        :   IN    std_logic;
        In1_re                            :   IN    std_logic_vector(17 DOWNTO 0);  -- sfix18_En15
        In1_im                            :   IN    std_logic_vector(17 DOWNTO 0);  -- sfix18_En15
        In2_re                            :   IN    std_logic_vector(1 DOWNTO 0);  -- sfix2
        In2_im                            :   IN    std_logic_vector(1 DOWNTO 0);  -- sfix2
        Out1_re                           :   OUT   std_logic_vector(17 DOWNTO 0);  -- sfix18_En15
        Out1_im                           :   OUT   std_logic_vector(17 DOWNTO 0)  -- sfix18_En15
        );
END ofdm_rx_src_PilotEq;


ARCHITECTURE rtl OF ofdm_rx_src_PilotEq IS

  -- Signals
  SIGNAL Delay2_out1_re                   : signed(17 DOWNTO 0);  -- sfix18_En15
  SIGNAL Delay2_out1_im                   : signed(17 DOWNTO 0);  -- sfix18_En15
  SIGNAL In2_re_signed                    : signed(1 DOWNTO 0);  -- sfix2
  SIGNAL In2_im_signed                    : signed(1 DOWNTO 0);  -- sfix2
  SIGNAL delayMatch_reg_re                : vector_of_signed2(0 TO 1);  -- sfix2 [2]
  SIGNAL delayMatch_reg_im                : vector_of_signed2(0 TO 1);  -- sfix2 [2]
  SIGNAL In2_re_1                         : signed(1 DOWNTO 0);  -- sfix2
  SIGNAL In2_im_1                         : signed(1 DOWNTO 0);  -- sfix2
  SIGNAL Delay3_out1_re                   : signed(1 DOWNTO 0);  -- sfix2
  SIGNAL Delay3_out1_im                   : signed(1 DOWNTO 0);  -- sfix2
  SIGNAL Product_mul_temp                 : signed(19 DOWNTO 0);  -- sfix20_En15
  SIGNAL Product_Re_AC                    : signed(17 DOWNTO 0);  -- sfix18_En15
  SIGNAL Product_Re_AC_1                  : signed(17 DOWNTO 0);  -- sfix18_En15
  SIGNAL Product2_mul_temp                : signed(19 DOWNTO 0);  -- sfix20_En15
  SIGNAL Product_Re_BD                    : signed(17 DOWNTO 0);  -- sfix18_En15
  SIGNAL Product1_mul_temp                : signed(19 DOWNTO 0);  -- sfix20_En15
  SIGNAL Product_Im_AD                    : signed(17 DOWNTO 0);  -- sfix18_En15
  SIGNAL Product_Im_AD_1                  : signed(17 DOWNTO 0);  -- sfix18_En15
  SIGNAL Product3_mul_temp                : signed(19 DOWNTO 0);  -- sfix20_En15
  SIGNAL Product_Im_BC                    : signed(17 DOWNTO 0);  -- sfix18_En15
  SIGNAL Product_Re_BD_1                  : signed(17 DOWNTO 0);  -- sfix18_En15
  SIGNAL mulOutput                        : signed(17 DOWNTO 0);  -- sfix18_En15
  SIGNAL Product_Im_BC_1                  : signed(17 DOWNTO 0);  -- sfix18_En15
  SIGNAL mulOutput_1                      : signed(17 DOWNTO 0);  -- sfix18_En15
  SIGNAL Delay5_bypass_reg_re             : signed(17 DOWNTO 0);  -- sfix18_En15
  SIGNAL Delay5_bypass_reg_im             : signed(17 DOWNTO 0);  -- sfix18_En15
  SIGNAL Product_out1_re                  : signed(17 DOWNTO 0);  -- sfix18_En15
  SIGNAL Product_out1_im                  : signed(17 DOWNTO 0);  -- sfix18_En15

BEGIN
  Delay2_out1_re <= signed(In1_re);

  In2_re_signed <= signed(In2_re);

  In2_im_signed <= signed(In2_im);

  delayMatch_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch_reg_re <= (OTHERS => to_signed(16#0#, 2));
      delayMatch_reg_im <= (OTHERS => to_signed(16#0#, 2));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_12_0 = '1' THEN
        delayMatch_reg_im(0) <= In2_im_signed;
        delayMatch_reg_im(1) <= delayMatch_reg_im(0);
        delayMatch_reg_re(0) <= In2_re_signed;
        delayMatch_reg_re(1) <= delayMatch_reg_re(0);
      END IF;
    END IF;
  END PROCESS delayMatch_process;

  In2_re_1 <= delayMatch_reg_re(1);
  In2_im_1 <= delayMatch_reg_im(1);

  Delay3_out1_re <= In2_re_1;

  Product_mul_temp <= Delay2_out1_re * Delay3_out1_re;
  Product_Re_AC <= Product_mul_temp(17 DOWNTO 0);

  PipelineRegister_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Product_Re_AC_1 <= to_signed(16#00000#, 18);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Product_Re_AC_1 <= Product_Re_AC;
      END IF;
    END IF;
  END PROCESS PipelineRegister_process;


  Delay2_out1_im <= signed(In1_im);

  Delay3_out1_im <= In2_im_1;

  Product2_mul_temp <= Delay2_out1_im * Delay3_out1_im;
  Product_Re_BD <= Product2_mul_temp(17 DOWNTO 0);

  Product1_mul_temp <= Delay2_out1_re * Delay3_out1_im;
  Product_Im_AD <= Product1_mul_temp(17 DOWNTO 0);

  PipelineRegister1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Product_Im_AD_1 <= to_signed(16#00000#, 18);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Product_Im_AD_1 <= Product_Im_AD;
      END IF;
    END IF;
  END PROCESS PipelineRegister1_process;


  Product3_mul_temp <= Delay2_out1_im * Delay3_out1_re;
  Product_Im_BC <= Product3_mul_temp(17 DOWNTO 0);

  PipelineRegister2_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Product_Re_BD_1 <= to_signed(16#00000#, 18);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Product_Re_BD_1 <= Product_Re_BD;
      END IF;
    END IF;
  END PROCESS PipelineRegister2_process;


  mulOutput <= Product_Re_AC_1 - Product_Re_BD_1;

  PipelineRegister3_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Product_Im_BC_1 <= to_signed(16#00000#, 18);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        Product_Im_BC_1 <= Product_Im_BC;
      END IF;
    END IF;
  END PROCESS PipelineRegister3_process;


  mulOutput_1 <= Product_Im_AD_1 + Product_Im_BC_1;

  Delay5_bypass_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Delay5_bypass_reg_re <= to_signed(16#00000#, 18);
      Delay5_bypass_reg_im <= to_signed(16#00000#, 18);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_1_12_1 = '1' THEN
        Delay5_bypass_reg_im <= mulOutput_1;
        Delay5_bypass_reg_re <= mulOutput;
      END IF;
    END IF;
  END PROCESS Delay5_bypass_process;

  
  Product_out1_re <= mulOutput WHEN enb_1_12_1 = '1' ELSE
      Delay5_bypass_reg_re;
  
  Product_out1_im <= mulOutput_1 WHEN enb_1_12_1 = '1' ELSE
      Delay5_bypass_reg_im;

  Out1_re <= std_logic_vector(Product_out1_re);

  Out1_im <= std_logic_vector(Product_out1_im);

END rtl;

